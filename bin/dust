#!/usr/bin/env ruby -w
require 'pp'

require 'rubygems'
$:.unshift File.join(File.dirname(__FILE__), *%w[.. lib])
require 'dust'

# {Constant => {Method => [Warnings]}}
$warnings = Hash.new {|h,k| h[k] = Hash.new {|_h,_k| _h[_k] = [] }}

require 'trollop'
opts = Trollop::options do
  opt :only, "Dust only classes/modules that match this string.", :type => :string, :multi => true
  opt :except, "Don't dust classes/modules that match this string.", :type => :string, :multi => true
end

puts "Options: #{opts.inspect}"
DustOptions = { :only => opts[:only] || [], :except => opts[:except] || []}
Dusters = [
  Dust::ArgumentDuster, Dust::BlockDuster, Dust::BranchDuster,
  Dust::LocalVariableDuster, Dust::MethodDuster, Dust::RescueDuster
]

class Class
  def method_added(name)
    return if DustOptions[:except].any? {|namespace| /#{namespace}/ =~ self.to_s }
    return unless DustOptions[:only].empty? or DustOptions[:only].any? {|namespace|  /#{namespace}/ =~ self.to_s }
    
    warnings = Dusters.map do |duster_class|
      duster = duster_class.new(self, name)
      duster.dust!
      duster.warnings
    end.flatten
    
    $warnings[self][name] = warnings
  end
end

at_exit do
  # Prune empty classes and methods
  $warnings.each do |klass, methods|
    methods.each do |meth, warnings|
      $warnings[klass].delete(meth) if warnings.empty?
    end
    $warnings.delete(klass) if $warnings[klass].empty?
  end
  
  puts "Nothing to report boss! He's clean!" if $warnings.empty?
  
  $warnings.each do |klass, methods|
    puts "#{klass}"
    methods.each do |meth, warnings|
      puts "  #{meth}"
      warnings.each do |w|
        puts "    - #{w.message}"
      end
    end
    puts
  end
end

ARGV.each {|file| load file }